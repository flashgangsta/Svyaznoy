package com.svyaznoy {	import com.flashgangsta.events.PopupsControllerEvent;	import com.flashgangsta.utils.PopupsController;	import com.flashgangsta.utils.Queue;	import com.svyaznoy.events.ProviderEvent;	import com.svyaznoy.events.RatingEvent;	import com.svyaznoy.utils.DateParser;	import flash.display.Stage;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.TimerEvent;	import flash.utils.getTimer;	import flash.utils.Timer;	/**	 * ...	 * @author Sergey Krivtsov (flashgangsta@gmail.com)	 */	public class AchievementsController extends EventDispatcher {				private const MAX_UPDATE_TIME:int = 5000;				//		static private var instance:AchievementsController;				private var provider:Provider = Provider.getInstance();		private var _isLoaded:Boolean;		private var list:Vector.<Object> = new Vector.<Object>();		private var notificationsQueue:Queue;		private var stage:Stage;		private var lastUpdate:int = 0;		private var timer:Timer;		private var lastNotificationTime:Number;		private var isUpdateMode:Boolean = false;				/**		 * 		 */				public function AchievementsController() {			if ( instance ) {				throw new Error( "AchievementsController is singletone" );			} else {				instance = this;			}		}				/**		 * 		 * @return		 */				static public function getInstance():AchievementsController {			if ( !instance ) instance = new AchievementsController();			return instance;		}				/**		 * 		 */				public function init( stage:Stage ):void {			this.stage = stage;			provider.getMyAchievements();						if ( !provider.hasEventListener( ProviderEvent.ON_MY_ACHIEVEMENTS ) ) {				provider.addEventListener( ProviderEvent.ON_MY_ACHIEVEMENTS, onMyAchievements );			}					}				/**		 * 		 * @return		 */				public function getList():Vector.<Object> {			return list;		}				/**		 * 		 */				public function checkNewAchiewements():void {			var delay:int = MAX_UPDATE_TIME - ( getTimer() - lastUpdate );						isUpdateMode = true;						if( delay < 1 ) {				provider.getMyAchievements();			} else {				timer = new Timer( delay, 1 );				timer.addEventListener( TimerEvent.TIMER, onDelay );			}		}				/**		 * 		 * @param	event		 */				private function onDelay( event:TimerEvent ):void {			timer.removeEventListener( TimerEvent.TIMER, onDelay );			checkNewAchiewements();		}				/**		 * 		 */				public function get isLoaded():Boolean {			return _isLoaded;		}				/**		 * 		 * @param	event		 */				private function onMyAchievements( event:ProviderEvent ):void {			var list:Array = event.data as Array;			var item:Object;			_isLoaded = true;						for ( var i:int = 0; i < list.length; i++ ) {				item = list[ i ];				item.updatedDate = DateParser.parse( item.updated_at );				item.updatedTime = item.updatedDate.time;			}						list.sortOn( "updatedTime", Array.NUMERIC );			this.list = Vector.<Object>( list );						checkNewAchievementsNotifications();						lastUpdate = getTimer();		}				/**		 * 		 */				private function checkNewAchievementsNotifications():void {			var helper:Helper = Helper.getInstance();						if ( !lastNotificationTime ) {				lastNotificationTime = helper.getUserData().lastAchievementDate ? helper.getUserData().lastAchievementDate.time : new Date().time;			}						for ( var i:int = 0; i < list.length; i++ ) {				if ( list[ i ].updatedTime > lastNotificationTime ) {					break;				}			}						if ( i < list.length ) {				notificationsQueue = new Queue();				for ( i; i < list.length; i++ ) {					notificationsQueue.add( showNewAchievement, list[ i ] );				}				notificationsQueue.applyFirst();				if ( isUpdateMode ) Dispatcher.getInstance().dispatchEvent( new RatingEvent( RatingEvent.OWNER_RATING_CHANGED ) );			}					}				/**		 * 		 * @param	data		 */				private function showNewAchievement( data:Object ):void {			trace( "Show achievement notify:", data.type + "_" + data.level );			var popup:AchievementSharingPopup = new AchievementSharingPopup( data );			popup.addEventListener( PopupsControllerEvent.CLOSED, onNotificationCompete );			PopupsController.getInstance().showPopup( popup, true );		}				/**		 * 		 * @param	event		*/				private function onNotificationCompete( event:Event ):void {			//AchievementNotification( event.target ).removeEventListener( Event.COMPLETE, onNotificationCompete );			event.target.removeEventListener( PopupsControllerEvent.CLOSED, onNotificationCompete );			if( notificationsQueue.length ) {				notificationsQueue.applyFirst();			} else {				//TODO сделать dispose			}		}			}}